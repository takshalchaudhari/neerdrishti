<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Neerdrishti – Filtered 2D + 3D Mapping</title>

<script src="paho-mqtt.js"></script>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.155.0/build/three.module.js";
import { OrbitControls } from "https://unpkg.com/three@0.155.0/examples/jsm/controls/OrbitControls.js";
window.THREE = THREE;
window.OrbitControls = OrbitControls;
</script>

<style>
body{margin:0;background:#050d12;color:#0f0;font-family:monospace;text-align:center}
canvas{background:#021;border-radius:8px}
#panels{display:flex;flex-wrap:wrap;justify-content:center}
#status{color:#ff0}
</style>
</head>

<body>

<h2>Neerdrishti – Phase 3-1 (Calibration + Filtering)</h2>
<p id="status">Connecting…</p>

Front: <span id="f">--</span> |
Left: <span id="l">--</span> |
Right: <span id="r">--</span>

<div id="panels">
  <canvas id="radar" width="400" height="400"></canvas>
  <canvas id="map" width="400" height="250"></canvas>
  <div id="three" style="width:420px;height:420px"></div>
</div>

<script type="module">
/* ================= CONFIG ================= */

// Calibration offsets (cm)
const CAL = {
  front: 0,
  left:  0,
  right: 0
};

// Valid distance window
const MIN_CM = 15;
const MAX_CM = 300;

// Filter parameters
const MEDIAN_WINDOW = 5;
const EMA_ALPHA = 0.35; // 0 = heavy smoothing, 1 = raw

/* ================= STATE ================= */

let raw = {front:0,left:0,right:0};
let filt = {front:0,left:0,right:0};
let ema  = {front:0,left:0,right:0};

const history = {
  front:[], left:[], right:[]
};

let lastMsg = 0;
let sweep = 0;

/* ================= FILTERS ================= */

function median(arr){
  const s = [...arr].sort((a,b)=>a-b);
  return s[Math.floor(s.length/2)];
}

function filter(name, value){
  // Calibration
  value += CAL[name];

  // Reject invalid
  if(value < MIN_CM || value > MAX_CM) return null;

  // Median window
  history[name].push(value);
  if(history[name].length > MEDIAN_WINDOW)
    history[name].shift();

  if(history[name].length < MEDIAN_WINDOW) return null;

  const m = median(history[name]);

  // EMA smoothing
  ema[name] = ema[name]
    ? EMA_ALPHA * m + (1-EMA_ALPHA) * ema[name]
    : m;

  return Math.round(ema[name]);
}

/* ================= 2D ================= */

const radar = document.getElementById("radar").getContext("2d");
const map = document.getElementById("map").getContext("2d");

function polar(a,d){
  const r = a*Math.PI/180;
  return {x:d*Math.cos(r),y:d*Math.sin(r)};
}

function draw2D(){
  radar.fillStyle="rgba(0,0,0,0.25)";
  radar.fillRect(0,0,400,400);
  radar.strokeStyle="#0f0";
  radar.beginPath();
  radar.arc(200,200,180,0,Math.PI*2);
  radar.stroke();

  sweep+=0.04;
  radar.beginPath();
  radar.moveTo(200,200);
  radar.lineTo(200+180*Math.cos(sweep),200+180*Math.sin(sweep));
  radar.stroke();

  [["left",-30],["front",0],["right",30]].forEach(s=>{
    if(!filt[s[0]]) return;
    const p = polar(s[1],filt[s[0]]);
    radar.fillRect(200+p.x/2,200+p.y/2,6,6);
  });

  map.fillStyle="#011";
  map.fillRect(0,0,400,250);

  [["left",-30],["front",0],["right",30]].forEach(s=>{
    if(!filt[s[0]]) return;
    const p = polar(s[1],filt[s[0]]);
    map.fillRect(200+p.x/2,240-p.y/2,6,6);
  });

  requestAnimationFrame(draw2D);
}
draw2D();

/* ================= 3D ================= */

const container=document.getElementById("three");
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x020a0f);

const camera=new THREE.PerspectiveCamera(60,1,1,2000);
camera.position.set(0,120,220);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(420,420);
container.appendChild(renderer.domElement);

const controls=new OrbitControls(camera,renderer.domElement);
controls.enableDamping=true;

scene.add(new THREE.GridHelper(400,20,0x00ff00,0x003300));

const geom=new THREE.BufferGeometry();
const pts=[];
const mat=new THREE.PointsMaterial({color:0x00ff00,size:4});
const cloud=new THREE.Points(geom,mat);
scene.add(cloud);

function add3D(a,d){
  const r=a*Math.PI/180;
  pts.push(d*Math.cos(r),0,-d*Math.sin(r));
  geom.setAttribute("position",new THREE.Float32BufferAttribute(pts,3));
}

function render3D(){
  controls.update();
  renderer.render(scene,camera);
  requestAnimationFrame(render3D);
}
render3D();

/* ================= MQTT ================= */

const statusEl=document.getElementById("status");

const client=new Paho.Client(
  "4d679eb8c29c4e029130d4045c0c1a2e.s1.eu.hivemq.cloud",
  8884,"/mqtt","web_"+Math.random().toString(16).slice(2)
);

client.onMessageArrived=m=>{
  const j=JSON.parse(m.payloadString);
  raw=j;
  lastMsg=Date.now();

  ["front","left","right"].forEach(k=>{
    const v=filter(k,j[k]);
    if(v){
      filt[k]=v;
      document.getElementById(k[0]).innerText=v;
      add3D(k==="front"?0:k==="left"?-30:30,v);
    }
  });

  statusEl.innerText="Live (filtered)";
};

client.onConnectionLost=()=>statusEl.innerText="MQTT lost";

client.connect({
  useSSL:true,
  onSuccess:()=>{
    statusEl.innerText="Connected";
    client.subscribe("neerdrishti/sonar/map");
  },
  onFailure:()=>statusEl.innerText="MQTT failed"
});

setInterval(()=>{
  if(Date.now()-lastMsg>3000)
    statusEl.innerText="No data";
},1000);
</script>

</body>
</html>
